diff -uNr src/conf.c src-hacc/conf.c
--- src/conf.c	2017-07-21 16:49:06.492583588 -0500
+++ src-hacc/conf.c	2017-07-21 20:36:11.537627902 -0500
@@ -253,22 +253,6 @@
 		conf_params->pw_relBoundRatio = pw_relBoundRatio;
 		segment_size = (int)iniparser_getint(ini, "PARAMETER:segment_size", 0);
 		conf_params->segment_size = segment_size;
-		
-		modeBuf = iniparser_getstring(ini, "PARAMETER:pwr_type", NULL);
-
-		if(strcmp(modeBuf, "MIN")==0)
-			pwr_type = SZ_PWR_MIN_TYPE;
-		else if(strcmp(modeBuf, "AVG")==0)
-			pwr_type = SZ_PWR_AVG_TYPE;
-		else if(strcmp(modeBuf, "MAX")==0)
-			pwr_type = SZ_PWR_MAX_TYPE;
-		else if(modeBuf!=NULL)
-		{
-			printf("[SZ] Error: Wrong pwr_type setting (please check sz.config file).\n");
-			iniparser_freedict(ini);
-			return SZ_NSCS;	
-		}
-		conf_params->pwr_type = pwr_type;
 	}
 	
 //	versionNumber[0] = SZ_VER_MAJOR; //0
diff -uNr src/sz.c src-hacc/sz.c
--- src/sz.c	2017-07-21 18:33:16.009825189 -0500
+++ src-hacc/sz.c	2017-07-21 20:36:11.537627902 -0500
@@ -44,8 +44,6 @@
 double relBoundRatio;
 double pw_relBoundRatio;
 int segment_size;
-int pwr_type = -1;
-
 int versionNumber[4] = {SZ_VER_MAJOR,SZ_VER_MINOR,SZ_VER_BUILD,SZ_VER_REVISION};
 
 int spaceFillingCurveTransform; //default is 0, or 1 set by sz.config
@@ -174,10 +172,6 @@
 			sampleDistance = params->sampleDistance;
 		if(params->predThreshold > 0)
 			predThreshold = params->predThreshold;
-		if(params->segment_size > 0)
-			segment_size = params->segment_size;
-		if(params->pwr_type > 0)
-			pwr_type = params->pwr_type;
     }
 
 //	versionNumber[0] = SZ_VER_MAJOR; //0
@@ -267,7 +261,7 @@
  **/
 /*-------------------------------------------------------------------------*/
 unsigned char* SZ_compress_args(int dataType, void *data, size_t *outSize, int errBoundMode, double absErrBound, 
-double relBoundRatio, double pwrBoundRatio, int pwrType, size_t r5, size_t r4, size_t r3, size_t r2, size_t r1)
+double relBoundRatio, size_t r5, size_t r4, size_t r3, size_t r2, size_t r1)
 {
 	//TODO
 	if(dataType==SZ_FLOAT)
@@ -275,7 +269,7 @@
 		unsigned char *newByteData;
 		
 		SZ_compress_args_float(&newByteData, (float *)data, r5, r4, r3, r2, r1, 
-		outSize, errBoundMode, absErrBound, relBoundRatio, pwrBoundRatio, pwrType);
+		outSize, errBoundMode, absErrBound, relBoundRatio);
 		
 		return newByteData;
 	}
@@ -283,7 +277,7 @@
 	{
 		unsigned char *newByteData;
 		SZ_compress_args_double(&newByteData, (double *)data, r5, r4, r3, r2, r1, 
-		outSize, errBoundMode, absErrBound, relBoundRatio, pwrBoundRatio, pwrType);
+		outSize, errBoundMode, absErrBound, relBoundRatio);
 		
 		return newByteData;
 	}
@@ -294,11 +288,10 @@
 	}
 }
 
-int SZ_compress_args2(int dataType, void *data, unsigned char* compressed_bytes, size_t *outSize, 
-int errBoundMode, double absErrBound, double relBoundRatio, double pwrBoundRatio, int pwrType, 
+int SZ_compress_args2(int dataType, void *data, unsigned char* compressed_bytes, size_t *outSize, int errBoundMode, double absErrBound, double relBoundRatio, 
 size_t r5, size_t r4, size_t r3, size_t r2, size_t r1)
 {
-	unsigned char* bytes = SZ_compress_args(dataType, data, outSize, errBoundMode, absErrBound, relBoundRatio, pwrBoundRatio, pwrType, r5, r4, r3, r2, r1);
+	unsigned char* bytes = SZ_compress_args(dataType, data, outSize, errBoundMode, absErrBound, relBoundRatio, r5, r4, r3, r2, r1);
     memcpy(compressed_bytes, bytes, *outSize);
     free(bytes); 
 	return SZ_SCES;
@@ -338,8 +331,7 @@
 
 unsigned char *SZ_compress(int dataType, void *data, size_t *outSize, size_t r5, size_t r4, size_t r3, size_t r2, size_t r1)
 {	
-	unsigned char *newByteData = SZ_compress_args(dataType, data, outSize, errorBoundMode, absErrBound, relBoundRatio, 
-	pw_relBoundRatio, pwr_type, r5, r4, r3, r2, r1);
+	unsigned char *newByteData = SZ_compress_args(dataType, data, outSize, errorBoundMode, absErrBound, relBoundRatio, r5, r4, r3, r2, r1);
 	return newByteData;
 }
 
diff -uNr src/sz_double.c src-hacc/sz_double.c
--- src/sz_double.c	2017-07-21 18:28:49.945545722 -0500
+++ src-hacc/sz_double.c	2017-07-21 20:36:11.534627933 -0500
@@ -32,8 +32,8 @@
 	{
 		if(i%sampleDistance==0)
 		{
-			pred_value = 2*oriData[i-1] - oriData[i-2];
-			//pred_value = oriData[i-1];
+			//pred_value = 2*oriData[i-1] - oriData[i-2];
+			pred_value = oriData[i-1];
 			pred_err = fabs(pred_value - oriData[i]);
 			radiusIndex = (unsigned long)((pred_err/realPrecision+1)/2);
 			if(radiusIndex>=maxRangeRadius)
@@ -297,8 +297,8 @@
 	{				
 		//printf("%.30G\n",last3CmprsData[0]);
 		curData = spaceFillingValue[i];
-		pred = 2*last3CmprsData[0] - last3CmprsData[1];
-		//pred = last3CmprsData[0];
+		//pred = 2*last3CmprsData[0] - last3CmprsData[1];
+		pred = last3CmprsData[0];
 		predAbsErr = fabs(curData - pred);	
 		if(predAbsErr<=checkRadius)
 		{
@@ -1434,21 +1434,11 @@
 
 int SZ_compress_args_double(unsigned char** newByteData, double *oriData, 
 size_t r5, size_t r4, size_t r3, size_t r2, size_t r1, size_t *outSize, 
-int errBoundMode, double absErr_Bound, double relBoundRatio, double pwRelBoundRatio, int pwrType)
+int errBoundMode, double absErr_Bound, double relBoundRatio)
 {
 	errorBoundMode = errBoundMode;
 	if(errBoundMode==PW_REL)
-	{
-		pw_relBoundRatio = pwRelBoundRatio;	
-		pwr_type = pwrType;
-		if(pwrType==SZ_PWR_AVG_TYPE && r3 != 0 )
-		{
-			printf("Error: Current version doesn't support 3D data compression with point-wise relative error bound being based on pwrType=AVG\n");
-			exit(0);
-			return SZ_NSCS;
-		}
-	}				
-		
+		pw_relBoundRatio = relBoundRatio;	
 	int status = SZ_SCES;
 	size_t dataLength = computeDataLength(r5,r4,r3,r2,r1);
 	double valueRangeSize = 0, medianValue = 0;
diff -uNr src/sz_double_pwr.c src-hacc/sz_double_pwr.c
--- src/sz_double_pwr.c	2017-07-21 19:10:05.637219363 -0500
+++ src-hacc/sz_double_pwr.c	2017-07-21 20:36:11.535627923 -0500
@@ -30,18 +30,12 @@
 	unsigned char realPrecBytes[8];
 	double curPrecision;
 	double curValue;
-	float sum = 0;
 	for(i=0;i<dataLength;i++)
 	{
 		curValue = oriData[i];
 		if(i%segment_size==0&&i>0)
 		{
 			//get two first bytes of the realPrecision
-			if(pwr_type==SZ_PWR_AVG_TYPE)
-			{
-				realPrecision = sum/segment_size;
-				sum = 0;			
-			}
 			doubleToBytes(realPrecBytes, realPrecision);
 			memset(&realPrecBytes[2], 0, 6);
 			approxPrecision = bytesToDouble(realPrecBytes);
@@ -55,28 +49,10 @@
 		else if(curValue!=0)
 		{
 			curPrecision = fabs(pw_relBoundRatio*curValue);
-			
-			switch(pwr_type)
-			{
-			case SZ_PWR_MIN_TYPE: 
-				if(realPrecision>curPrecision)
-					realPrecision = curPrecision;	
-				break;
-			case SZ_PWR_AVG_TYPE:
-				sum += curPrecision;
-				break;
-			case SZ_PWR_MAX_TYPE:
-				if(realPrecision<curPrecision)
-					realPrecision = curPrecision;					
-				break;
-			}
+			if(realPrecision>curPrecision)
+				realPrecision = curPrecision;
 		}
 	}
-	if(pwr_type==SZ_PWR_AVG_TYPE)
-	{
-		int size = dataLength%segment_size==0?segment_size:dataLength%segment_size;
-		realPrecision = sum/size;		
-	}	
 	doubleToBytes(realPrecBytes, realPrecision);
 	memset(&realPrecBytes[2], 0, 6);
 	approxPrecision = bytesToDouble(realPrecBytes);
@@ -102,8 +78,8 @@
 			realPrecision = pwrErrBound[j++];
 		if(i%sampleDistance==0)
 		{
-			pred_value = 2*oriData[i-1] - oriData[i-2];
-			//pred_value = oriData[i-1];
+			//pred_value = 2*oriData[i-1] - oriData[i-2];
+			pred_value = oriData[i-1];
 			pred_err = fabs(pred_value - oriData[i]);
 			radiusIndex = (unsigned long)((pred_err/realPrecision+1)/2);
 			if(radiusIndex>=maxRangeRadius)
@@ -141,19 +117,11 @@
 	double approxPrecision;
 	unsigned char realPrecBytes[8];
 	double curValue, curAbsValue;
-	double* statAbsValues = (double*)malloc(R2*sizeof(double));	
+	double* minAbsValues = (double*)malloc(R2*sizeof(double));	
 	
 	double max = fabs(Min)<fabs(Max)?fabs(Max):fabs(Min); //get the max abs value.
-	double min = fabs(Min)<fabs(Max)?fabs(Min):fabs(Max);
 	for(i=0;i<R2;i++)
-	{
-		if(pwr_type == SZ_PWR_MIN_TYPE)
-			statAbsValues[i] = max;
-		else if(pwr_type == SZ_PWR_MAX_TYPE)
-			statAbsValues[i] = min;
-		else
-			statAbsValues[i] = 0; //for SZ_PWR_AVG_TYPE
-	}
+		minAbsValues[i] = max;
 	for(i=0;i<r1;i++)
 	{
 		for(j=0;j<r2;j++)
@@ -162,27 +130,7 @@
 			curValue = oriData[index];				
 			if(((i%edgeSize==edgeSize-1 || i==r1-1) &&j%edgeSize==0&&j>0) || (i%edgeSize==0&&j==0&&i>0))
 			{
-				if(pwr_type==SZ_PWR_AVG_TYPE)
-				{
-					int a = edgeSize, b = edgeSize;
-					if(j==0)
-					{
-						if(r2%edgeSize==0) 
-							b = edgeSize;
-						else
-							b = r2%edgeSize;
-					}
-					if(i==r1-1)
-					{
-						if(r1%edgeSize==0)
-							a = edgeSize;
-						else
-							a = r1%edgeSize;
-					}
-					realPrecision = pw_relBoundRatio*statAbsValues[J]/(a*b);
-				}
-				else
-					realPrecision = pw_relBoundRatio*statAbsValues[J];
+				realPrecision = pw_relBoundRatio*minAbsValues[J];
 				doubleToBytes(realPrecBytes, realPrecision);
 				memset(&realPrecBytes[2], 0, 6);
 				approxPrecision = bytesToDouble(realPrecBytes);
@@ -191,12 +139,7 @@
 				//put the two bytes in pwrErrBoundBytes
 				pwrErrBoundBytes[k++] = realPrecBytes[0];
 				pwrErrBoundBytes[k++] = realPrecBytes[1];	
-				if(pwr_type == SZ_PWR_MIN_TYPE)
-					statAbsValues[J] = max;
-				else if(pwr_type == SZ_PWR_MAX_TYPE)
-					statAbsValues[J] = min;
-				else
-					statAbsValues[J] = 0; //for SZ_PWR_AVG_TYPE		
+				minAbsValues[J] = max;		
 			}	
 			if(j==0)
 				J = 0;
@@ -205,41 +148,12 @@
 			if(curValue!=0)
 			{
 				curAbsValue = fabs(curValue);
-				
-				switch(pwr_type)
-				{
-				case SZ_PWR_MIN_TYPE: 
-					if(statAbsValues[J]>curAbsValue)
-						statAbsValues[J] = curAbsValue;	
-					break;
-				case SZ_PWR_AVG_TYPE:
-					statAbsValues[J] += curAbsValue;
-					break;
-				case SZ_PWR_MAX_TYPE:
-					if(statAbsValues[J]<curAbsValue)
-						statAbsValues[J] = curAbsValue;					
-					break;
-				}
+				if(minAbsValues[J]>curAbsValue)
+					minAbsValues[J] = curAbsValue;
 			}
 		}
 	}
-		
-	if(pwr_type==SZ_PWR_AVG_TYPE)
-	{
-		int a = edgeSize, b = edgeSize;
-		if(r2%edgeSize==0) 
-			b = edgeSize;
-		else
-			b = r2%edgeSize;
-		if(r1%edgeSize==0)
-			a = edgeSize;
-		else
-			a = r1%edgeSize;
-		realPrecision = pw_relBoundRatio*statAbsValues[J]/(a*b);
-	}
-	else
-		realPrecision = pw_relBoundRatio*statAbsValues[J];		
-		
+	realPrecision = pw_relBoundRatio*minAbsValues[J];
 	doubleToBytes(realPrecBytes, realPrecision);
 	realPrecBytes[2] = realPrecBytes[3] = 0;
 	approxPrecision = bytesToDouble(realPrecBytes);
@@ -249,7 +163,7 @@
 	pwrErrBoundBytes[k++] = realPrecBytes[0];
 	pwrErrBoundBytes[k++] = realPrecBytes[1];	
 	
-	free(statAbsValues);
+	free(minAbsValues);
 }
 
 unsigned int optimize_intervals_double_2D_pwr(double *oriData, size_t r1, size_t r2, size_t R2, size_t edgeSize, double* pwrErrBound)
@@ -580,8 +494,8 @@
 			interval = 2*realPrecision;
 			updateReqLength = 0;
 		}
-		pred = 2*last3CmprsData[0] - last3CmprsData[1];
-		//pred = last3CmprsData[0];
+		//pred = 2*last3CmprsData[0] - last3CmprsData[1];
+		pred = last3CmprsData[0];
 		predAbsErr = fabs(curData - pred);	
 		if(predAbsErr<checkRadius)
 		{
diff -uNr src/sz_float.c src-hacc/sz_float.c
--- src/sz_float.c	2017-07-21 18:11:54.242959798 -0500
+++ src-hacc/sz_float.c	2017-07-21 20:36:11.535627923 -0500
@@ -32,8 +32,8 @@
 	{
 		if(i%sampleDistance==0)
 		{
-			pred_value = 2*oriData[i-1] - oriData[i-2];
-			//pred_value = oriData[i-1];
+			//pred_value = 2*oriData[i-1] - oriData[i-2];
+			pred_value = oriData[i-1];
 			pred_err = fabs(pred_value - oriData[i]);
 			radiusIndex = (unsigned long)((pred_err/realPrecision+1)/2);
 			if(radiusIndex>=maxRangeRadius)
@@ -297,8 +297,8 @@
 //		if(i==2869438)
 //			printf("i=%d\n", i);
 		curData = spaceFillingValue[i];
-		pred = 2*last3CmprsData[0] - last3CmprsData[1];
-		//pred = last3CmprsData[0];
+		//pred = 2*last3CmprsData[0] - last3CmprsData[1];
+		pred = last3CmprsData[0];
 		predAbsErr = fabs(curData - pred);	
 		if(predAbsErr<=checkRadius)
 		{
@@ -1442,20 +1442,11 @@
 
 int SZ_compress_args_float(unsigned char** newByteData, float *oriData, 
 size_t r5, size_t r4, size_t r3, size_t r2, size_t r1, size_t *outSize, 
-int errBoundMode, double absErr_Bound, double relBoundRatio, double pwRelBoundRatio, int pwrType)
+int errBoundMode, double absErr_Bound, double relBoundRatio)
 {
 	errorBoundMode = errBoundMode;
 	if(errBoundMode==PW_REL)
-	{
-		pw_relBoundRatio = pwRelBoundRatio;	
-		pwr_type = pwrType;
-		if(pwrType==SZ_PWR_AVG_TYPE && r3 != 0 )
-		{
-			printf("Error: Current version doesn't support 3D data compression with point-wise relative error bound being based on pwrType=AVG\n");
-			exit(0);
-			return SZ_NSCS;
-		}
-	}		
+		pw_relBoundRatio = relBoundRatio;	
 	int status = SZ_SCES;
 	size_t dataLength = computeDataLength(r5,r4,r3,r2,r1);
 	float valueRangeSize = 0, medianValue = 0;
diff -uNr src/sz_float_pwr.c src-hacc/sz_float_pwr.c
--- src/sz_float_pwr.c	2017-07-21 19:03:08.855491763 -0500
+++ src-hacc/sz_float_pwr.c	2017-07-21 20:36:11.534627933 -0500
@@ -31,18 +31,12 @@
 	unsigned char realPrecBytes[4];
 	float curPrecision;
 	float curValue;
-	float sum = 0;
 	for(i=0;i<dataLength;i++)
 	{
 		curValue = oriData[i];
 		if(i%segment_size==0&&i>0)
 		{
 			//get two first bytes of the realPrecision
-			if(pwr_type==SZ_PWR_AVG_TYPE)
-			{
-				realPrecision = sum/segment_size;
-				sum = 0;			
-			}
 			floatToBytes(realPrecBytes, realPrecision);
 			realPrecBytes[2] = realPrecBytes[3] = 0;
 			approxPrecision = bytesToFloat(realPrecBytes);
@@ -51,33 +45,15 @@
 			//put the two bytes in pwrErrBoundBytes
 			pwrErrBoundBytes[k++] = realPrecBytes[0];
 			pwrErrBoundBytes[k++] = realPrecBytes[1];
+			realPrecision = curValue!=0?fabs(pw_relBoundRatio*curValue):pw_relBoundRatio;
 		}
-		
-		if(curValue!=0)
+		else if(curValue!=0)
 		{
 			curPrecision = fabs(pw_relBoundRatio*curValue);
-			
-			switch(pwr_type)
-			{
-			case SZ_PWR_MIN_TYPE: 
-				if(realPrecision>curPrecision)
-					realPrecision = curPrecision;	
-				break;
-			case SZ_PWR_AVG_TYPE:
-				sum += curPrecision;
-				break;
-			case SZ_PWR_MAX_TYPE:
-				if(realPrecision<curPrecision)
-					realPrecision = curPrecision;					
-				break;
-			}
+			if(realPrecision>curPrecision)
+				realPrecision = curPrecision;
 		}
 	}
-	if(pwr_type==SZ_PWR_AVG_TYPE)
-	{
-		int size = dataLength%segment_size==0?segment_size:dataLength%segment_size;
-		realPrecision = sum/size;		
-	}	
 	floatToBytes(realPrecBytes, realPrecision);
 	realPrecBytes[2] = realPrecBytes[3] = 0;
 	approxPrecision = bytesToFloat(realPrecBytes);
@@ -103,8 +79,8 @@
 			realPrecision = pwrErrBound[j++];
 		if(i%sampleDistance==0)
 		{
-			pred_value = 2*oriData[i-1] - oriData[i-2];
-			//pred_value = oriData[i-1];
+			//pred_value = 2*oriData[i-1] - oriData[i-2];
+			pred_value = oriData[i-1];
 			pred_err = fabs(pred_value - oriData[i]);
 			radiusIndex = (unsigned long)((pred_err/realPrecision+1)/2);
 			if(radiusIndex>=maxRangeRadius)
@@ -143,19 +119,11 @@
 	float approxPrecision;
 	unsigned char realPrecBytes[4];
 	float curValue, curAbsValue;
-	float* statAbsValues = (float*)malloc(R2*sizeof(float));
+	float* minAbsValues = (float*)malloc(R2*sizeof(float));
 	
 	float max = fabs(Min)<fabs(Max)?fabs(Max):fabs(Min); //get the max abs value.
-	float min = fabs(Min)<fabs(Max)?fabs(Min):fabs(Max);
 	for(i=0;i<R2;i++)
-	{
-		if(pwr_type == SZ_PWR_MIN_TYPE)
-			statAbsValues[i] = max;
-		else if(pwr_type == SZ_PWR_MAX_TYPE)
-			statAbsValues[i] = min;
-		else
-			statAbsValues[i] = 0; //for SZ_PWR_AVG_TYPE
-	}
+		minAbsValues[i] = max;
 	for(i=0;i<r1;i++)
 	{
 		for(j=0;j<r2;j++)
@@ -164,28 +132,7 @@
 			curValue = oriData[index];				
 			if(((i%edgeSize==edgeSize-1 || i==r1-1) &&j%edgeSize==0&&j>0) || (i%edgeSize==0&&j==0&&i>0))
 			{
-				if(pwr_type==SZ_PWR_AVG_TYPE)
-				{
-					int a = edgeSize, b = edgeSize;
-					if(j==0)
-					{
-						if(r2%edgeSize==0) 
-							b = edgeSize;
-						else
-							b = r2%edgeSize;
-					}
-					if(i==r1-1)
-					{
-						if(r1%edgeSize==0)
-							a = edgeSize;
-						else
-							a = r1%edgeSize;
-					}
-					realPrecision = pw_relBoundRatio*statAbsValues[J]/(a*b);
-				}
-				else
-					realPrecision = pw_relBoundRatio*statAbsValues[J];
-					
+				realPrecision = pw_relBoundRatio*minAbsValues[J];
 				floatToBytes(realPrecBytes, realPrecision);
 				realPrecBytes[2] = realPrecBytes[3] = 0;
 				approxPrecision = bytesToFloat(realPrecBytes);
@@ -194,13 +141,7 @@
 				//put the two bytes in pwrErrBoundBytes
 				pwrErrBoundBytes[k++] = realPrecBytes[0];
 				pwrErrBoundBytes[k++] = realPrecBytes[1];	
-				
-				if(pwr_type == SZ_PWR_MIN_TYPE)
-					statAbsValues[J] = max;
-				else if(pwr_type == SZ_PWR_MAX_TYPE)
-					statAbsValues[J] = min;
-				else
-					statAbsValues[J] = 0; //for SZ_PWR_AVG_TYPE	
+				minAbsValues[J] = max;		
 			}	
 			if(j==0)
 				J = 0;
@@ -209,41 +150,12 @@
 			if(curValue!=0)
 			{
 				curAbsValue = fabs(curValue);
-				
-				switch(pwr_type)
-				{
-				case SZ_PWR_MIN_TYPE: 
-					if(statAbsValues[J]>curAbsValue)
-						statAbsValues[J] = curAbsValue;	
-					break;
-				case SZ_PWR_AVG_TYPE:
-					statAbsValues[J] += curAbsValue;
-					break;
-				case SZ_PWR_MAX_TYPE:
-					if(statAbsValues[J]<curAbsValue)
-						statAbsValues[J] = curAbsValue;					
-					break;
-				}
+				if(minAbsValues[J]>curAbsValue)
+					minAbsValues[J] = curAbsValue;
 			}
 		}
 	}
-		
-	if(pwr_type==SZ_PWR_AVG_TYPE)
-	{
-		int a = edgeSize, b = edgeSize;
-		if(r2%edgeSize==0) 
-			b = edgeSize;
-		else
-			b = r2%edgeSize;
-		if(r1%edgeSize==0)
-			a = edgeSize;
-		else
-			a = r1%edgeSize;
-		realPrecision = pw_relBoundRatio*statAbsValues[J]/(a*b);
-	}
-	else
-		realPrecision = pw_relBoundRatio*statAbsValues[J];		
-		
+	realPrecision = pw_relBoundRatio*minAbsValues[J];
 	floatToBytes(realPrecBytes, realPrecision);
 	realPrecBytes[2] = realPrecBytes[3] = 0;
 	approxPrecision = bytesToFloat(realPrecBytes);
@@ -253,7 +165,7 @@
 	pwrErrBoundBytes[k++] = realPrecBytes[0];
 	pwrErrBoundBytes[k++] = realPrecBytes[1];	
 	
-	free(statAbsValues);
+	free(minAbsValues);
 }
 
 unsigned int optimize_intervals_float_2D_pwr(float *oriData, size_t r1, size_t r2, size_t R2, size_t edgeSize, float* pwrErrBound)
@@ -586,8 +498,8 @@
 			interval = 2*realPrecision;
 			updateReqLength = 0;
 		}
-		pred = 2*last3CmprsData[0] - last3CmprsData[1];
-		//pred = last3CmprsData[0];
+		//pred = 2*last3CmprsData[0] - last3CmprsData[1];
+		pred = last3CmprsData[0];
 		predAbsErr = fabs(curData - pred);	
 		if(predAbsErr<checkRadius)
 		{
diff -uNr src/TightDataPointStorageD.c src-hacc/TightDataPointStorageD.c
--- src/TightDataPointStorageD.c	2017-07-19 22:52:02.128010194 -0500
+++ src-hacc/TightDataPointStorageD.c	2017-07-21 20:36:11.534627933 -0500
@@ -326,8 +326,8 @@
 			memcpy(preBytes,curBytes,8);
 			break;
 		default:
-			predValue = 2 * (*data)[i-1] - (*data)[i-2];
-			//predValue = (*data)[i-1];
+			//predValue = 2 * (*data)[i-1] - (*data)[i-2];
+			predValue = (*data)[i-1];
 			(*data)[i] = predValue + (type_-intvRadius)*interval;
 			break;
 		}
diff -uNr src/TightDataPointStorageD_pwr.c src-hacc/TightDataPointStorageD_pwr.c
--- src/TightDataPointStorageD_pwr.c	2017-07-18 16:30:17.653272516 -0500
+++ src-hacc/TightDataPointStorageD_pwr.c	2017-07-21 20:36:11.535627923 -0500
@@ -115,8 +115,8 @@
 			memcpy(preBytes,curBytes,8);
 			break;
 		default:
-			predValue = 2 * (*data)[i-1] - (*data)[i-2];
-			//predValue = (*data)[i-1];
+			//predValue = 2 * (*data)[i-1] - (*data)[i-2];
+			predValue = (*data)[i-1];
 			(*data)[i] = predValue + (type_-intvRadius)*interval;
 			break;
 		}
diff -uNr src/TightDataPointStorageF.c src-hacc/TightDataPointStorageF.c
--- src/TightDataPointStorageF.c	2017-07-20 14:41:44.110738169 -0500
+++ src-hacc/TightDataPointStorageF.c	2017-07-21 20:36:11.535627923 -0500
@@ -320,8 +320,8 @@
 			memcpy(preBytes,curBytes,4);
 			break;
 		default:
-			predValue = 2 * (*data)[i-1] - (*data)[i-2];
-			//predValue = (*data)[i-1];
+			//predValue = 2 * (*data)[i-1] - (*data)[i-2];
+			predValue = (*data)[i-1];
 			(*data)[i] = predValue + (type_-intvRadius)*interval;
 			break;
 		}
diff -uNr src/TightDataPointStorageF_pwr.c src-hacc/TightDataPointStorageF_pwr.c
--- src/TightDataPointStorageF_pwr.c	2017-07-18 16:31:53.302241436 -0500
+++ src-hacc/TightDataPointStorageF_pwr.c	2017-07-21 20:36:11.535627923 -0500
@@ -121,8 +121,8 @@
 			memcpy(preBytes,curBytes,4);
 			break;
 		default:
-			predValue = 2 * (*data)[i-1] - (*data)[i-2];
-			//predValue = (*data)[i-1];
+			//predValue = 2 * (*data)[i-1] - (*data)[i-2];
+			predValue = (*data)[i-1];
 			(*data)[i] = predValue + (type_-intvRadius)*interval;
 			break;
 		}
